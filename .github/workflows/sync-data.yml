name: Sync Data Files (frontend â†” backend)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# WHAT THIS DOES:
#   Whenever a file inside frontend/data/ OR backend/data/ is changed,
#   this workflow copies that file to the OTHER data folder automatically.
#
#   frontend/data/countries.json  â”€â”€changedâ”€â”€â–º  backend/data/countries.json
#   backend/data/countries.json   â”€â”€changedâ”€â”€â–º  frontend/data/countries.json
#   frontend/data/questions.json  â”€â”€changedâ”€â”€â–º  backend/data/questions.json
#   backend/data/questions.json   â”€â”€changedâ”€â”€â–º  frontend/data/questions.json
#
#   Works for ANY file inside data/ â€” add new files anytime, they sync too.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

on:
  push:
    branches: [main]
    paths:
      - "frontend/data/**"
      - "backend/data/**"

  # Manual trigger (Actions tab â†’ Run workflow)
  workflow_dispatch:
    inputs:
      force_sync:
        description: "Force sync ALL data files (both directions)"
        required: false
        default: "false"
        type: choice
        options:
          - "false"
          - "true"

# Only one sync job runs at a time â€” prevents race conditions
concurrency:
  group: sync-data
  cancel-in-progress: false

jobs:
  sync:
    name: Sync data files
    runs-on: ubuntu-latest

    # Skip if this commit was made BY this workflow (prevent infinite loop)
    if: |
      github.actor != 'github-actions[bot]' &&
      !contains(github.event.head_commit.message, '[skip sync]') &&
      !contains(github.event.head_commit.message, '[sync]')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2   # Need previous commit to detect changed files
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect changed data files
        id: detect
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‚ Detecting changed data files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          FORCE="${{ github.event.inputs.force_sync }}"

          if [ "$FORCE" = "true" ]; then
            echo "âš¡ Force sync mode â€” syncing ALL data files"

            # List every file in both data folders
            ALL_FILES=$(find frontend/data backend/data -type f 2>/dev/null | sort)
            echo "Found files:"
            echo "$ALL_FILES"

            # Build the changed-files list: take unique filenames
            FILENAMES=$(find frontend/data backend/data -type f -exec basename {} \; 2>/dev/null | sort -u)
          else
            # Get list of files changed in this push
            CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only HEAD 2>/dev/null)
            echo "Changed files in this push:"
            echo "$CHANGED"

            # Filter to only data folder files
            DATA_CHANGED=$(echo "$CHANGED" | grep -E '^(frontend|backend)/data/' || true)

            if [ -z "$DATA_CHANGED" ]; then
              echo "â„¹ï¸  No data files changed. Nothing to sync."
              echo "has_changes=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "Data files changed:"
            echo "$DATA_CHANGED"

            # Extract unique filenames (e.g. countries.json, questions.json)
            FILENAMES=$(echo "$DATA_CHANGED" | xargs -I{} basename {} | sort -u)
          fi

          echo "Files to sync: $FILENAMES"
          echo "filenames<<EOF" >> "$GITHUB_OUTPUT"
          echo "$FILENAMES" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "has_changes=true" >> "$GITHUB_OUTPUT"

      - name: Sync files bidirectionally
        id: sync
        if: steps.detect.outputs.has_changes == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”„ Starting bidirectional sync..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          SYNCED=0
          SKIPPED=0
          ERRORS=0
          SYNC_LOG=""

          FRONTEND_DIR="frontend/data"
          BACKEND_DIR="backend/data"

          while IFS= read -r filename; do
            [ -z "$filename" ] && continue

            FRONTEND_FILE="$FRONTEND_DIR/$filename"
            BACKEND_FILE="$BACKEND_DIR/$filename"

            echo ""
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "ğŸ“„ Processing: $filename"

            FE_EXISTS=false
            BE_EXISTS=false
            [ -f "$FRONTEND_FILE" ] && FE_EXISTS=true
            [ -f "$BACKEND_FILE"  ] && BE_EXISTS=true

            # â”€â”€ Case 1: Both exist â†’ sync whichever was more recently changed â”€â”€
            if [ "$FE_EXISTS" = "true" ] && [ "$BE_EXISTS" = "true" ]; then

              # Compare SHA256 checksums â€” if identical, skip
              FE_HASH=$(sha256sum "$FRONTEND_FILE" | awk '{print $1}')
              BE_HASH=$(sha256sum "$BACKEND_FILE"  | awk '{print $1}')

              if [ "$FE_HASH" = "$BE_HASH" ]; then
                echo "âœ… Files are identical â€” no sync needed"
                SKIPPED=$((SKIPPED + 1))
                SYNC_LOG="$SYNC_LOG\nâ­ï¸  $filename â€” already in sync"
                continue
              fi

              # Determine which file was changed in this commit
              FORCE="${{ github.event.inputs.force_sync }}"
              CHANGED_IN_COMMIT=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")

              FE_CHANGED=$(echo "$CHANGED_IN_COMMIT" | grep -c "frontend/data/$filename" || true)
              BE_CHANGED=$(echo "$CHANGED_IN_COMMIT" | grep -c "backend/data/$filename" || true)

              if [ "$FORCE" = "true" ]; then
                # Force mode: frontend is source of truth
                SOURCE="$FRONTEND_FILE"
                DEST="$BACKEND_FILE"
                DIRECTION="frontend â†’ backend"
              elif [ "$FE_CHANGED" -gt 0 ] && [ "$BE_CHANGED" -gt 0 ]; then
                # Both changed in same commit â€” frontend wins (arbitrary but consistent)
                echo "âš ï¸  Both changed simultaneously â€” frontend takes priority"
                SOURCE="$FRONTEND_FILE"
                DEST="$BACKEND_FILE"
                DIRECTION="frontend â†’ backend (conflict resolved)"
              elif [ "$FE_CHANGED" -gt 0 ]; then
                SOURCE="$FRONTEND_FILE"
                DEST="$BACKEND_FILE"
                DIRECTION="frontend â†’ backend"
              elif [ "$BE_CHANGED" -gt 0 ]; then
                SOURCE="$BACKEND_FILE"
                DEST="$FRONTEND_FILE"
                DIRECTION="backend â†’ frontend"
              else
                # Changed by some other means (e.g. force_sync on unrelated commit)
                # Use modification time as tiebreaker
                FE_MOD=$(stat -c %Y "$FRONTEND_FILE" 2>/dev/null || echo 0)
                BE_MOD=$(stat -c %Y "$BACKEND_FILE"  2>/dev/null || echo 0)
                if [ "$FE_MOD" -ge "$BE_MOD" ]; then
                  SOURCE="$FRONTEND_FILE"
                  DEST="$BACKEND_FILE"
                  DIRECTION="frontend â†’ backend (newer mtime)"
                else
                  SOURCE="$BACKEND_FILE"
                  DEST="$FRONTEND_FILE"
                  DIRECTION="backend â†’ frontend (newer mtime)"
                fi
              fi

              cp "$SOURCE" "$DEST"
              echo "âœ… Synced: $DIRECTION"
              SYNCED=$((SYNCED + 1))
              SYNC_LOG="$SYNC_LOG\nâœ… $filename â€” $DIRECTION"

            # â”€â”€ Case 2: Only frontend exists â†’ copy to backend â”€â”€
            elif [ "$FE_EXISTS" = "true" ] && [ "$BE_EXISTS" = "false" ]; then
              mkdir -p "$BACKEND_DIR"
              cp "$FRONTEND_FILE" "$BACKEND_FILE"
              echo "âœ… Created in backend (was missing): $filename"
              SYNCED=$((SYNCED + 1))
              SYNC_LOG="$SYNC_LOG\nâœ… $filename â€” frontend â†’ backend (new file)"

            # â”€â”€ Case 3: Only backend exists â†’ copy to frontend â”€â”€
            elif [ "$FE_EXISTS" = "false" ] && [ "$BE_EXISTS" = "true" ]; then
              mkdir -p "$FRONTEND_DIR"
              cp "$BACKEND_FILE" "$FRONTEND_FILE"
              echo "âœ… Created in frontend (was missing): $filename"
              SYNCED=$((SYNCED + 1))
              SYNC_LOG="$SYNC_LOG\nâœ… $filename â€” backend â†’ frontend (new file)"

            # â”€â”€ Case 4: Neither exists (shouldn't happen) â”€â”€
            else
              echo "âš ï¸  File '$filename' not found in either location â€” skipping"
              ERRORS=$((ERRORS + 1))
              SYNC_LOG="$SYNC_LOG\nâš ï¸  $filename â€” not found anywhere"
            fi

          done <<< "${{ steps.detect.outputs.filenames }}"

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š Sync Summary:"
          echo "   âœ… Synced  : $SYNCED file(s)"
          echo "   â­ï¸  Skipped : $SKIPPED file(s)"
          echo "   âš ï¸  Errors  : $ERRORS file(s)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          echo "synced=$SYNCED" >> "$GITHUB_OUTPUT"
          echo "skipped=$SKIPPED" >> "$GITHUB_OUTPUT"
          printf "sync_log=%b\n" "$SYNC_LOG" >> "$GITHUB_OUTPUT"

      - name: Commit synced files
        if: |
          steps.detect.outputs.has_changes == 'true' &&
          steps.sync.outputs.synced != '0'
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add frontend/data/ backend/data/

          # Only commit if there are actual staged changes
          if git diff --cached --quiet; then
            echo "â„¹ï¸  No file differences to commit (already in sync)."
          else
            SYNCED="${{ steps.sync.outputs.synced }}"
            FILENAMES=$(echo "${{ steps.detect.outputs.filenames }}" | tr '\n' ' ' | xargs)

            git commit -m "sync: data files synced ($FILENAMES) [sync] [skip ci]"
            git push

            echo "âœ… Committed and pushed synced data files."
          fi

      - name: Print final status
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ Workflow complete"
          if [ "${{ steps.detect.outputs.has_changes }}" = "false" ]; then
            echo "   No data files were changed â€” nothing to do."
          else
            echo "   Synced : ${{ steps.sync.outputs.synced }} file(s)"
            echo "   Skipped: ${{ steps.sync.outputs.skipped }} file(s)"
          fi
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
